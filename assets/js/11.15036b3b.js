(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{573:function(n,t,s){"use strict";s.r(t);var e=s(16),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("blockquote",[s("p",[n._v("本篇重点关注以下 3 点：")]),n._v(" "),s("ol",[s("li",[n._v("Golang 基础网络编程")]),n._v(" "),s("li",[n._v("所谓 「TCP 粘包问题」")]),n._v(" "),s("li",[n._v("如何解决「TCP 粘包问题」")])])]),n._v(" "),s("h2",{attrs:{id:"基础网络编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础网络编程"}},[n._v("#")]),n._v(" 基础网络编程")]),n._v(" "),s("p",[n._v("这是 sidergo 系列教程的第一篇，但是开篇不涉及 sidergo 相关的内容，而是把重点放在网络编程，因为 sidergo 的实现第一步就是 C/S 网络编程。")]),n._v(" "),s("p",[n._v("sidergo/redis-cli 之间的通信通过是 TCP 协议，所以我们从一个简单的 Golang 网络编程代码开始。")]),n._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('// client/main.go\nfunc main() {\n\tconn, _ := net.Dial("tcp", ":8081")\n\tcontent := "hello\\nworld\\nand\\ngoodbye\\n"\n\tn, err := conn.Write([]byte(content))\n\tfmt.Println(n, err)\n}\n\n//server/main.go\nfunc main() {\n\tlistener, _ := net.Listen("tcp", ":8081")\n\tfor {\n\t\tconn, _ := listener.Accept()\n\t\tgo func(conn net.Conn) {\n\t\t\tbuf := bufio.NewReader(conn)\n\t\t\tfor {\n\t\t\t\tbuffer, err := buf.ReadBytes(\'\\n\')\n\t\t\t\ttime.Sleep(time.Second)  // 注意这里的 sleep\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\tfmt.Print(string(buffer))\n\t\t\t\t}\n\t\t\t}\n\t\t}(conn)\n\t}\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br")])]),s("p",[n._v("分别运行 client 和 server，server 端会每隔 1s 输出：")]),n._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[n._v("➜  sidergo git:"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("master"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" ✗ go run example/server/main.go\nhello\nworld\nand\ngoodbye\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("上面的代码可以很容易的从网上找到并且有详细的解释，这里不做过多的说明。这边我们重点要弄清 一个问题：")]),n._v(" "),s("ol",[s("li",[n._v("client 是一次性发送整个 content，但是 server 却每次只读到部分内容？（不是一次性输出 content，而是间隔 1s 输出部分内容，所以说 server 每次只读只到部分内容）")])]),n._v(" "),s("p",[n._v("这个问题可以很简单的回答：因为 "),s("code",[n._v("buf.ReadBytes('\\n')")]),n._v("  会逐个字节的读取 client 发送过来的内容，直到读取到 "),s("code",[n._v("\\n")]),n._v(" 之后返回。如果 client 发送过来的内容全部读取完毕，那么就返回 "),s("code",[n._v("io.EOF")]),n._v(" 表示内容读取完毕。而就是这个简单代码就解决了大名鼎鼎的「TCP 粘包问题」。")]),n._v(" "),s("h2",{attrs:{id:"所谓「tcp-粘包问题」"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所谓「tcp-粘包问题」"}},[n._v("#")]),n._v(" 所谓「TCP 粘包问题」")]),n._v(" "),s("blockquote",[s("p",[n._v("首先要指出：「TCP 粘包问题」本身就不是一个正确的描述，但是在很多地方甚至包括面试给你挖坑都会碰到这个名词，所以这里也不正确的使用这个词")])]),n._v(" "),s("p",[n._v("那什么是")]),n._v(" "),s("p",[n._v("可能你不是很熟悉 TCP/IP 协议、三次握手/四次挥手等网络相关内容，没关系，我们也可以屏蔽那些细节，从高一点的角度理解 TCP 粘包问题。")]),n._v(" "),s("p",[n._v("TCP 是一个基于「字节流」的传输层通信协议，这里重点在「字节流」。基于字节流的意思是：不管传输的数据是文本、图片、还是视频，在 TCP 层都是将数据变成字节流发送给对方，所以上面 "),s("code",[n._v("hello\\nworld\\nand\\ngoodbye\\n")]),n._v(" 在 TCP 层是这样传递的：")])])}),[],!1,null,null,null);t.default=a.exports}}]);